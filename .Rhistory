separate_wider_regex(
str,
patterns = c(
"<",
name = "[A-Za-z]+",
">-",
gender = ".",
"_",
age = "[0-9]+"
)
)
# 15.4 Pattern details ---------------------------------------------------------
# escaping, anchors, character classes, quantifiers, operator precedence and
# parentheses, and grouping components of the pattern
# 15.4.1 Escaping -------------------------------------------------------------
# To create the regular expression \., we need to use \\.
dot <- "\\."
dot
# But the expression itself only contains one \
str_view(dot)
# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")
# more escape examples
x <- "a\\b"
str_view(x)
str_view(x, "\\\\")
# raw strings
str_view(x, r"{\\}")
# an alternative to using a backslash escape: you can use a character
# class: [.], [$], [|], … all match the literal values.
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")
str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")
# 15.4.2 Anchors ---------------------------------------------------------------
# ^ to match the start or $ to match the end:
fruit
str_view(fruit, "^a")
str_view(fruit, "a$")
str_view(fruit, "apple")
str_view(fruit, "^apple$")
# boundary between words with \b
x <- c("summary(x)", "summarize(df)", "rowsum(x)", "sum(x)")
x
str_view(x, "sum")
str_view(x, "\\bsum\\b")
# When used alone, anchors will produce a zero-width match
str_view("abc", c("$", "^", "\\b"))
str_replace_all("abc", c("$", "^", "\\b"), "--")
# 15.4.3 Character classes -----------------------------------------------------
# A character class, or character set, allows you to match any character in a set.
# Note: [^abc] matches any character *except* “a”, “b”, or “c”.
# - defines a range, e.g., [a-z] matches any lower case letter and [0-9] matches any number.
# \ escapes special characters, so [\^\-\]] matches ^, -, or ].
# \d matches any digit;
# \D matches anything that isn’t a digit.
# \s matches any whitespace (e.g., space, tab, newline);
# \S matches anything that isn’t whitespace.
# \w matches any “word” character, i.e. letters and numbers;
# \W matches any “non-word” character.
x <- "abcd ABCD 12345 -!@#%."
x
str_view(x, "[abc]+")
str_view(x, "[^a-z0-9]+")
# You need an escape to match characters that are otherwise
# special inside of []
str_view("a-b-c", "[a-c]")
str_view("a-b-c", "[a\\-c]")
# see shortcuts above
x <- "abcd ABCD 12345 -!@#%."
x
# \d matches any digit;
str_view(x, "\\d+")
# \D matches anything that isn’t a digit.
str_view(x, "\\D+")
# \s matches any whitespace (e.g., space, tab, newline);
str_view(x, "\\s+")
# \S matches anything that isn’t whitespace.
str_view(x, "\\S+")
# \w matches any “word” character, i.e. letters and numbers;
str_view(x, "\\w+")
# \W matches any “non-word” character.
str_view(x, "\\W+")
# 15.4.4 Quantifiers -----------------------------------------------------------
# You can also specify the number of matches precisely with {}
# {n} matches exactly n times.
# {n,} matches at least n times.
# {n,m} matches between n and m times.
# 15.4.5 Operator precedence and parentheses ----------------------------------
# quantifiers have high precedence and alternation has low precedence which
# means that ab+ is equivalent to a(b+), and ^a|b$ is equivalent to (^a)|(b$).
# Just like with algebra, you can use parentheses to override the usual order.
# But unlike algebra you’re unlikely to remember the precedence rules for
# regexes, so feel free to use parentheses liberally.
# 15.4.6 Grouping and capturing ------------------------------------------------
#  back reference: \1 refers to the match contained in the first parenthesis,
#  \2 in the second parenthesis, and so on
# all fruit that has repeated pairs
str_view(fruit, "(..)\\1")
# all words that start and end with the same pair of letters
str_view(words, "^(..).*\\1$")
# using back references in str_replace()
# this code switches the order of the second and third words in sentences
str_view(sentences)
sentences |>
str_replace("(\\w+) (\\w+) (\\w+)", "\\1 \\3 \\2") |>
str_view()
# extracting the matches for each group using str_match().
# Note - str_match() returns a matrix, so it’s not particularly easy
# to work with
sentences |>
str_match("the (\\w+) (\\w+)") |>
head()
# Converting to a tibble
# separate_wider_regex() uses similar code behind the scenes
sentences |>
str_match("the (\\w+) (\\w+)") |>
as_tibble(.name_repair = "minimal") |>
set_names("match", "word1", "word2")
# using parentheses without creating matching groups
x <- c("a gray cat", "a grey dog")
str_match(x, "gr(e|a)y")
# 15.4.7 Exercises
str_view(fruit, "apple|melon|nut")
babynames |>
group_by(year) |>
summarize(prop_x = mean(str_detect(name, "x"))) |>
ggplot(aes(x = year, y = prop_x)) +
geom_line()
df <- tribble(
~str,
"<Sheryl>-F_34",
"<Kisha>-F_45",
"<Brandon>-N_33",
"<Sharon>-F_38",
"<Penny>-F_58",
"<Justin>-M_41",
"<Patricia>-F_84",
)
df
# 15.3.4 Extract variables -----------------------------------------------------
df <- tribble(
~str,
"<Sheryl>-F_34",
"<Kisha>-F_45",
"<Brandon>-N_33",
"<Sharon>-F_38",
"<Penny>-F_58",
"<Justin>-M_41",
"<Patricia>-F_84",
)
df |>
separate_wider_regex(
str,
patterns = c(
"<",
name = "[A-Za-z]+",
">-",
gender = ".",
"_",
age = "[0-9]+"
)
)
# 15.4 Pattern details ---------------------------------------------------------
# escaping, anchors, character classes, quantifiers, operator precedence and
# parentheses, and grouping components of the pattern
# 15.4.1 Escaping -------------------------------------------------------------
# To create the regular expression \., we need to use \\.
dot <- "\\."
dot
# But the expression itself only contains one \
str_view(dot)
# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")
# more escape examples
x <- "a\\b"
str_view(x)
str_view(x, "\\\\")
# raw strings
str_view(x, r"{\\}")
# an alternative to using a backslash escape: you can use a character
# class: [.], [$], [|], … all match the literal values.
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")
str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")
my_string = str_view(x, "\\\\")
my_string
my_string = str_view(x, "\\\\")
print(my_string)
# 15.4.1 Escaping -------------------------------------------------------------
# To create the regular expression \., we need to use \\.
dot <- "\\."
dot
# But the expression itself only contains one \
str_view(dot)
# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")
# more escape examples
x <- "a\\b"
str_view(x)
my_string = str_view(x, "\\\\")
print(my_string)
# raw strings
str_view(x, r"{\\}")
# an alternative to using a backslash escape: you can use a character
# class: [.], [$], [|], … all match the literal values.
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")
str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")
# 15.4.2 Anchors ---------------------------------------------------------------
# ^ to match the start or $ to match the end:
fruit
str_view(fruit, "^a")
str_view(fruit, "a$")
str_view(fruit, "apple")
str_view(fruit, "^apple$")
# boundary between words with \b
x <- c("summary(x)", "summarize(df)", "rowsum(x)", "sum(x)")
x
str_view(x, "sum")
str_view(x, "\\bsum\\b")
# When used alone, anchors will produce a zero-width match
str_view("abc", c("$", "^", "\\b"))
str_replace_all("abc", c("$", "^", "\\b"), "--")
# 15.4.3 Character classes -----------------------------------------------------
# A character class, or character set, allows you to match any character in a set.
# Note: [^abc] matches any character *except* “a”, “b”, or “c”.
# - defines a range, e.g., [a-z] matches any lower case letter and [0-9] matches any number.
# \ escapes special characters, so [\^\-\]] matches ^, -, or ].
# \d matches any digit;
# \D matches anything that isn’t a digit.
# \s matches any whitespace (e.g., space, tab, newline);
# \S matches anything that isn’t whitespace.
# \w matches any “word” character, i.e. letters and numbers;
# \W matches any “non-word” character.
x <- "abcd ABCD 12345 -!@#%."
x
str_view(x, "[abc]+")
str_view(x, "[^a-z0-9]+")
# You need an escape to match characters that are otherwise
# special inside of []
str_view("a-b-c", "[a-c]")
str_view("a-b-c", "[a\\-c]")
# see shortcuts above
x <- "abcd ABCD 12345 -!@#%."
x
# \d matches any digit;
str_view(x, "\\d+")
# \D matches anything that isn’t a digit.
str_view(x, "\\D+")
# \s matches any whitespace (e.g., space, tab, newline);
str_view(x, "\\s+")
# \S matches anything that isn’t whitespace.
str_view(x, "\\S+")
# \w matches any “word” character, i.e. letters and numbers;
str_view(x, "\\w+")
# \W matches any “non-word” character.
str_view(x, "\\W+")
# Ch15 - Regular Expressions
#===============================================================================
library(tidyverse)
library(babynames)
# 15.3.5 Exercises -------------------------------------------------------------
#  1. What baby name has the most vowels? What name has the highest proportion of
#  vowels? (Hint: what is the denominator?)
df <- babynames |>
count(name) |>
mutate(
name = str_to_lower(name),
vowels = str_count(name, "[aeiou]"),
) |>
arrange(desc(vowels))
df
df <- df |>
mutate(
prop_vowels = vowels / n
)|>
arrange(desc(vowels))
df
#  2. Replace all forward slashes in "a/b/c/d/e" with backslashes. What happens if
#   you attempt to undo the transformation by replacing all backslashes with
#   forward slashes? (We’ll discuss the problem very soon.)
my_string <- c("a/b/c/d/e")
my_string <- str_replace_all(my_string, "//", "\\")
# This throws the error below...
# my_string <- str_replace_all(my_string, "\\", "//")
# Error in stri_replace_all_regex(string, pattern, fix_replacement(replacement),  :
#      Unrecognized backslash escape sequence in pattern. (U_REGEX_BAD_ESCAPE_SEQUENCE, context=`\`)
#  3. Implement a simple version of str_to_lower() using str_replace_all().
my_string <- c("This is My String")
str_replace_all(my_string, "[A-Z]", tolower)
#  4. Create a regular expression that will match telephone numbers as commonly
#  written in your country.
tel_number = C('(417) 732-2662')
tel_number = C('(417) 732-2662')
tel_number = C("(417) 732-2662")
el_number = C("\(417\) 732-2662")
test = c( '(')
test = c( '(')
test = c( '(')
test
test = c( '(417)')
test
test = c( '(417) 732')
test
test = c( '(417) 732-')
test
test = c( '(417) 732-2662')
test
tel_number <- C("(417) 732-2662")
test <- c( '(417) 732-2662')
tel_no <- c( '(417) 732-2662')
tel_no
str_view(tel_no, "(\\d{3})\\d{3}\-\\d{4}")
tel_no <- c( '(417) 732-2662')
str_view(tel_no, "(\\d{3})")
str_view(tel_no, "(\\d+)")
str_view(tel_no, "(\\d+)")
#  4. Create a regular expression that will match telephone numbers as commonly
tel_no <- c( '(417) 732-2662')
str_view(tel_no, "(\\d+)")
str_view(tel_no, "(\\d+)")
str_view(tel_no, "\\d+")
str_view(tel_no, "(")
str_view(tel_no, "\(")
str_view(tel_no, "\\(")
str_view(tel_no, "\\(\\d+")
str_view(tel_no, "\\(\\d+\\)")
str_view(tel_no, "\\(\\d+\\)\\d+\\-")
tel_no <- c( '(417) 732-2662')
str_view(tel_no, "\\(\\d+\\)\\d+\\-")
str_view(tel_no, "\\(\\d+\\)\\d+")
str_view(tel_no, "\\(\\d+\\)")
str_view(tel_no, "\\(\\d+\\)")
str_view(tel_no, "\\(\\d+\\)\\d+")
str_view(tel_no, "\\(\\d+\\)d+")
str_view(tel_no, "\\([0-9])")
str_view(tel_no, "\\(\\d+)")
str_view(tel_no, "\\(\\d+\\)")
str_view(tel_no, "\\(\\d+\\) [0-9]")
str_view(tel_no, "\\(\\d+\\) [0-9]+")
str_view(tel_no, "\\(\\d+\\) [0-9]+ "-")
str_view(tel_no, "\\(\\d+\\) [0-9]+ \\- )
str_view(tel_no, "\\(\\d+\\) [0-9]+ \-" )
str_view(tel_no, "\\(\\d+\\) [0-9]+ \\-" )
str_view(tel_no, "\\(\\d+\\) [0-9]+ -" )
str_view(tel_no, "\\(\\d+\\) [0-9]+" )
str_view(tel_no, "\\(\\d+\\) [0-9]+ \-")
str_view(tel_no, "\\(\\d+\\) [0-9]+ \\-")
str_view(tel_no, "\\(\\d+\\) [0-9]+\\-")
str_view(tel_no, "\\(\\d+\\) [0-9]+\\-[0-9]")
str_view(tel_no, "\\(\\d+\\) [0-9]+\\-[0-9]+")
# Ch15 - Regular Expressions
#===============================================================================
library(tidyverse)
library(babynames)
# 15.3.5 Exercises -------------------------------------------------------------
#  1. What baby name has the most vowels? What name has the highest proportion of
#  vowels? (Hint: what is the denominator?)
df <- babynames |>
count(name) |>
mutate(
name = str_to_lower(name),
vowels = str_count(name, "[aeiou]"),
) |>
arrange(desc(vowels))
df
df <- df |>
mutate(
prop_vowels = vowels / n
)|>
arrange(desc(vowels))
df
#  2. Replace all forward slashes in "a/b/c/d/e" with backslashes. What happens if
#   you attempt to undo the transformation by replacing all backslashes with
#   forward slashes? (We’ll discuss the problem very soon.)
my_string <- c("a/b/c/d/e")
my_string <- str_replace_all(my_string, "//", "\\")
# This throws the error below...
# my_string <- str_replace_all(my_string, "\\", "//")
# Error in stri_replace_all_regex(string, pattern, fix_replacement(replacement),  :
#      Unrecognized backslash escape sequence in pattern. (U_REGEX_BAD_ESCAPE_SEQUENCE, context=`\`)
#  3. Implement a simple version of str_to_lower() using str_replace_all().
my_string <- c("This is My String")
str_replace_all(my_string, "[A-Z]", tolower)
#  4. Create a regular expression that will match telephone numbers as commonly
tel_no <- c( '(417) 732-2662')
str_view(tel_no, "\\(\\d+\\) [0-9]+\\-[0-9]+")
ls <- c("\\'\\\\?")
ls
ls <- c("'\\\\?")
ls
# 15.4.7 Exercises -------------------------------------------------------------
# 1, How would you match the literal string "'\? How about "$^$"?
ls <- c("'\\\\?")
ls
ls <- c("'\\?")
ls
ls <- c("'\?")
ls <- c("'?")
ls
ls <- c("'\\?")
ls
ls <- c("'\?")
ls <- c("'?")
ls
ls <- c("'\\\?")
ls <- c("'\\")
ls
ls <- "'\\"
ls
ls <- "'\\"
ls
ls
ls <- "\'\\"
ls
ls <- "\' \\"
ls
ls <- "\\"
ls
ls <- "\\"
strview(ls)
ls <- "\\"
str_view(ls)
ls <- "\'\\"
str_view(ls)
ls <- "\'\\"
ls <- str_view(ls)
ls
ls <- "\'\\"
ls <- str_view(ls)
str_view(ls, "\'\\")
ls <- str_c("\', \\")
ls
ls <- str_c("\'", "\\")
ls
ls <- str_c("'", "\\")
ls
ls <- str_c("'", "\\\\")
ls
x <- "C:\\\\Users\\\\jd\\\\Documents\\\\folder\\\\file.txt"
x
x <- "C:\\Users\\jd\\Documents\\folder\\file.txt"
x
# Ch15 - Regular Expressions
#===============================================================================
library(tidyverse)
library(babynames)
# 15.3.5 Exercises -------------------------------------------------------------
#  1. What baby name has the most vowels? What name has the highest proportion of
#  vowels? (Hint: what is the denominator?)
df <- babynames |>
count(name) |>
mutate(
name = str_to_lower(name),
vowels = str_count(name, "[aeiou]"),
) |>
arrange(desc(vowels))
df
df <- df |>
mutate(
prop_vowels = vowels / n
)|>
arrange(desc(vowels))
df
#  2. Replace all forward slashes in "a/b/c/d/e" with backslashes. What happens if
#   you attempt to undo the transformation by replacing all backslashes with
#   forward slashes? (We’ll discuss the problem very soon.)
my_string <- c("a/b/c/d/e")
my_string <- str_replace_all(my_string, "//", "\\")
# This throws the error below...
# my_string <- str_replace_all(my_string, "\\", "//")
# Error in stri_replace_all_regex(string, pattern, fix_replacement(replacement),  :
#      Unrecognized backslash escape sequence in pattern. (U_REGEX_BAD_ESCAPE_SEQUENCE, context=`\`)
#  3. Implement a simple version of str_to_lower() using str_replace_all().
my_string <- c("This is My String")
str_replace_all(my_string, "[A-Z]", tolower)
#  4. Create a regular expression that will match telephone numbers as commonly
tel_no <- c( '(417) 732-2662')
str_view(tel_no, "\\(\\d+\\) [0-9]+\\-[0-9]+")
# 15.4.7 Exercises -------------------------------------------------------------
# 1, How would you match the literal string "'\" ? How about "$^$"?
ls <- str_c("'", "\\\\")
ls
str_view(ls, "\'\\")
x <- "C:\\Users\\jd\\Documents\\folder\\file.txt"
x
x <- "C:\Users\jd\Documents\folder\file.txt"
x <- "C:\\Users\\jd\\Documents\\folder\\file.txt"
str_view(x)
ls <- str_c("'", "\\\\")
str_view(ls, "\'\\")
str_view("\'\\")
str_view("\'\\")
ls <- str_view("\'\\")
ls <- str_view("\'\\")
ls
str_match(ls, "\'\\")
ls <- str_view("\'\\")
ls
str_match(ls, "\'")
ls <- str_view("\'\\")
ls
str_match(ls, "\' \\ ")
ls <- c("\'\\")
ls
ls <- c("\'\\")
ls
str_view(ls)
str_match(ls, "\'\\ ")
str_match(ls, "\' ")
str_match(ls, "\'")
str_match(ls, "\'\\")
ls <- c("\'\\")
ls
str_view(ls)
